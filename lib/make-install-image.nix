## This function creates a tarball that contains an almost complete
## NixOS system by copying the closure of the toplevel derivation of a
## given system configuration.  The configuration is composed of a
## complete nixpkgs directory tree and a directory that contains a
## nixos configuration.  The former must be supplied as a "channel
## derivation", i.e. the output of <nix/unpack-channel.nix>.  This
## derivation will be included in the system and configured as initial
## nixos channel.
##
##
{
  pkgs

, lib

, system

  # A derivation that contains a copy of the NixOS sources of the
  # system in the form of a channel named "nixos".
, channel

, # The absolute path to a directory that will be
  # copied to /etc/nixos on the system.  It must contain a file
  # named configuration.nix, which will be included as a module
  # when the system configuration is evaluated.
  #
  nixosConfigDir

, # The relative path to configuration stored within nixosConfigDir directory
  nixosConfigPath

, # A file with an attribute set that contains the configuration
  # options serialUnit and linuxConsoleConfig from the installImage
  # configuration. it can be included in the system configuration to
  # make these parameters configurable.
  serialConfig

, # A list of packages whose closures will be added to
  # that of systemConfigPath.  It is used to add packages
  # which are not part of the system closure in the default
  # NixOS configuraion (e.g. because a service is disabled
  # by default).
  additionalPkgs

, # The name of the tarball to store in the derivation. The compression
  # algorithm is chosen based on the extension of the name via the
  # "--auto-compress" feature of tar.
  tarballName

}:

with lib;

let
  ## pkgs collection from the channel
  channelPkgs = (import (channel + "/nixos") {}).pkgs;

  ## Create the system configuration from the supplied NixOS system
  ## definition.  The closure of the system.build.toplevel derivation
  ## will be installed on the client.  The actual configuration of the
  ## installed client will be slightly different due to the
  ## hardware-dependent components generated by
  ## "nixos-generate-config".  At the end of the installation process,
  ## the installer essentially executes "nix-env -p
  ## /nix/var/nix/profiles/system -f '<nixpkgs/nixos>' --set -A
  ## system" to generate the final configuration, which is executed in
  ## the context of the supplied channel.
  ##
  ## To avoid fetching of sources or substitutes as much as possible
  ## at that point, we include the closures of a number of store paths
  ## (see activationPkgs below).  This list has been obtained
  ## heuristically and is almost certainly incomplete (some
  ## installation targets may have to have Internet access during the
  ## installation process). It is important that those packages are
  ## evaluated within the context of the channel (as opposed to the
  ## pkgs with which we have been called).

  ## This one is special. It is an implicit dependency of
  ## system.build.initialRamdisk built by
  ## <nixpkgs/nixos/modules/system/boot/stage-1.nix>.  It cannot be
  ## reached through <nixpkgs> and needs to be re-created here.
  ## FIXME: this will probably break at some point.
  kmodBlacklistUbuntu = channelPkgs.runCommand "initrd-kmod-blacklist-ubuntu"
    { src = "${channelPkgs.kmod-blacklist-ubuntu}/modprobe.conf"; }
    ''
      target=$out
      ${channelPkgs.perl}/bin/perl -0pe 's/## file: iwlwifi.conf(.+?)##/##/s;' $src > $out
    '';

  activationPkgs = with channelPkgs; [
    stdenv
    stdenvNoCC
    busybox
    binutils
    libxslt
    kmodBlacklistUbuntu
    config.system.build.bootStage1
    config.system.build.bootStage2
    ## More odd packages seen to be needed on some systems.
    nukeReferences
    desktop-file-utils
    texinfo
    xorg.lndir
  ];
  nixosConfig = pkgs.runCommand "nixos-configuration" {}
    ''
      mkdir $out
      cd $out
      cp ${serialConfig} serial-config.nix
      (cd ${nixosConfigDir} && tar --exclude="*~" --exclude="#*" \
        -cf - .) | tar xf -
    '';
  extraConfig = {
    ## Avoid certain assertion failures
    #TODO: this part should not be executed if provided w/ user conf.
    #fileSystems."/".device = "/none";
    #boot.loader.grub.device = "/none";
  };
  config =(import (channel + "/nixos/nixos/lib/eval-config.nix") {
    inherit system;
    modules = [ extraConfig (nixosConfig + "/" + nixosConfigPath) ];
  }).config;

  version = builtins.unsafeDiscardStringContext
    (builtins.substring 33 (-1) (baseNameOf channel));

  binPath = with pkgs; makeBinPath (
    [ config.system.build.nixos-install
      nix
    ] ++ stdenv.initialPath);

  closureInfo = pkgs.closureInfo {
    rootPaths = [ config.system.build.toplevel channel ]
                ++ additionalPkgs
                ++ activationPkgs;
  };

in pkgs.runCommand "install-tarball-${version}" {}
  ''
    export PATH=${binPath}

    mkdir $out
    root="$PWD/root"
    mkdir -p $root

    export HOME=$TMPDIR

    # Provide a Nix database so that nixos-install can copy closures.
    export NIX_STATE_DIR=$TMPDIR/state
    nix-store --load-db < ${closureInfo}/registration

    echo "running nixos-install..."
    nixos-install --root $root --no-bootloader --no-root-passwd \
      --system ${config.system.build.toplevel} --channel ${channel} --substituters ""

    # Add remaining store paths which are not part of the system closure.
    for path in $(cat ${closureInfo}/store-paths); do
      if ! [ -e $root/$path ]; then
        echo "adding store path $path"

        nix-env --store $root -p $root/nix/var/nix/profiles/foo \
          --set $path --substituters "" --extra-substituters 'auto?trusted=1'
        rm $root/nix/var/nix/profiles/foo
      fi
    done

    mkdir -p $root/etc/nixos
    cp -prd ${nixosConfig}/* $root/etc/nixos

    echo "creating tarball..."
    cd $root && tar -caf $out/${tarballName} .
  ''
